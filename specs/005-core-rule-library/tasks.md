# Tasks: Core Rule Library

**Input**: Design documents from `/specs/005-core-rule-library/`  
**Prerequisites**: plan.md, spec.md, research.md, data-model.md, contracts/rule-contracts.md, quickstart.md  
**Tests**: OPTIONAL - Tests are only included if explicitly requested. This feature does not explicitly request TDD.

**Organization**: Tasks are grouped by user story to enable independent implementation and testing of each story.

## Format: `[ID] [P?] [Story] Description`

- **[P]**: Can run in parallel (different files, no dependencies)
- **[Story]**: Which user story this task belongs to (e.g., US1, US2, US3)
- Include exact file paths in descriptions

---

## Phase 1: Setup (Shared Infrastructure)

**Purpose**: Add new diagnostic categories required by all rules

- [ ] T001 Add DiagnosticCategories.CodeSmell constant in src/Lintelligent.AnalyzerEngine/Results/DiagnosticCategories.cs with XML doc comment "Code smells that indicate potential maintainability issues"
- [ ] T002 Add DiagnosticCategories.Documentation constant in src/Lintelligent.AnalyzerEngine/Results/DiagnosticCategories.cs with XML doc comment "Documentation quality issues"
- [ ] T003 Verify constants are accessible: dotnet build succeeds with no compilation errors

**Checkpoint**: New categories available for use by all rules

---

## Phase 2: User Story 8 - Long Method Enhancement (Priority: P2)

**Purpose**: Enhance existing rule to use new category system - this validates the infrastructure before adding new rules

**‚ö†Ô∏è CRITICAL**: This phase must complete before new rule implementations

- [ ] T004 Update LongMethodRule.Category property to return DiagnosticCategories.CodeSmell in src/Lintelligent.AnalyzerEngine/Rules/LongMethodRule.cs
- [ ] T005 Update LongMethodRule diagnostic message to include method name, statement count, and fix guidance "Consider extracting logical blocks into separate methods" in src/Lintelligent.AnalyzerEngine/Rules/LongMethodRule.cs
- [ ] T006 Verify existing LongMethodRuleTests still pass: dotnet test --filter "FullyQualifiedName~LongMethodRuleTests"
- [ ] T007 Add test assertions for new category and message format in tests/Lintelligent.AnalyzerEngine.Tests/Rules/LongMethodRuleTests.cs

**Checkpoint**: Foundation ready - new rule implementations can now proceed in parallel

---

## Phase 3: User Story 6 - Exception Swallowing Detection (Priority: P1) üéØ MVP

**Goal**: Detect empty catch blocks that silently suppress exceptions

**Independent Test**: Analyze try-catch with empty catch block - rule returns diagnostic with severity Warning, category "Code Smell", message "Empty catch block suppresses exceptions"

**Why MVP**: Simplest P1 rule (zero statements check), high severity issue, validates complete rule implementation pattern

### Implementation for User Story 6

- [ ] T008 [P] [US6] Create ExceptionSwallowingRule class implementing IAnalyzerRule in src/Lintelligent.AnalyzerEngine/Rules/ExceptionSwallowingRule.cs with Id="LNT007", Description="Catch blocks should not be empty", Severity=Warning, Category=CodeSmell
- [ ] T009 [US6] Implement Analyze method using DescendantNodes().OfType<CatchClauseSyntax>() to find catch blocks in src/Lintelligent.AnalyzerEngine/Rules/ExceptionSwallowingRule.cs
- [ ] T010 [US6] Add auto-generated code detection (skip files with <auto-generated> comment or *.Designer.cs pattern) in src/Lintelligent.AnalyzerEngine/Rules/ExceptionSwallowingRule.cs
- [ ] T011 [US6] Implement empty block detection: yield diagnostic when catch.Block.Statements.Count == 0 in src/Lintelligent.AnalyzerEngine/Rules/ExceptionSwallowingRule.cs
- [ ] T012 [US6] Set diagnostic message: "Empty catch block suppresses exceptions. Consider logging the exception or removing the try-catch if error handling is not needed." in src/Lintelligent.AnalyzerEngine/Rules/ExceptionSwallowingRule.cs
- [ ] T013 [P] [US6] Create ExceptionSwallowingRuleTests test class in tests/Lintelligent.AnalyzerEngine.Tests/Rules/ExceptionSwallowingRuleTests.cs
- [ ] T014 [P] [US6] Add test: ReturnsNoDiagnostic_WhenCatchBlockHasThrowStatement using CSharpSyntaxTree.ParseText() in tests/Lintelligent.AnalyzerEngine.Tests/Rules/ExceptionSwallowingRuleTests.cs
- [ ] T015 [P] [US6] Add test: ReturnsDiagnostic_WhenCatchBlockIsEmpty in tests/Lintelligent.AnalyzerEngine.Tests/Rules/ExceptionSwallowingRuleTests.cs
- [ ] T016 [P] [US6] Add test: ReturnsDiagnostic_WhenCatchBlockHasOnlyComments in tests/Lintelligent.AnalyzerEngine.Tests/Rules/ExceptionSwallowingRuleTests.cs
- [ ] T017 [P] [US6] Add test: ReturnsNoDiagnostic_WhenCatchBlockHasLogging in tests/Lintelligent.AnalyzerEngine.Tests/Rules/ExceptionSwallowingRuleTests.cs
- [ ] T018 [P] [US6] Add test: ReturnsDiagnostic_OnlyForOuterCatch_WhenNestedTryCatch in tests/Lintelligent.AnalyzerEngine.Tests/Rules/ExceptionSwallowingRuleTests.cs
- [ ] T019 [P] [US6] Add test: VerifiesCorrectMetadata_RuleIdSeverityCategory in tests/Lintelligent.AnalyzerEngine.Tests/Rules/ExceptionSwallowingRuleTests.cs
- [ ] T020 [US6] Run tests and verify all pass: dotnet test --filter "FullyQualifiedName~ExceptionSwallowingRuleTests"

**Checkpoint**: User Story 6 complete and independently testable - validates full rule implementation pattern

---

## Phase 4: User Story 1 - Long Parameter List Detection (Priority: P1)

**Goal**: Detect methods with more than 5 parameters

**Independent Test**: Analyze method with 6 parameters - rule returns diagnostic "Method has 6 parameters (max: 5)" with severity Warning, category "Code Smell"

### Implementation for User Story 1

- [ ] T021 [P] [US1] Create LongParameterListRule class implementing IAnalyzerRule in src/Lintelligent.AnalyzerEngine/Rules/LongParameterListRule.cs with Id="LNT002", Description="Methods should not have more than 5 parameters", Severity=Warning, Category=CodeSmell
- [ ] T022 [US1] Implement Analyze method using DescendantNodes().OfType<BaseMethodDeclarationSyntax>() in src/Lintelligent.AnalyzerEngine/Rules/LongParameterListRule.cs
- [ ] T023 [US1] Add auto-generated code detection in src/Lintelligent.AnalyzerEngine/Rules/LongParameterListRule.cs
- [ ] T024 [US1] Implement parameter counting logic: exclude 'this' parameter for extension methods, count remaining parameters in src/Lintelligent.AnalyzerEngine/Rules/LongParameterListRule.cs
- [ ] T025 [US1] Yield diagnostic when parameter count > 5 with message: "Method '{methodName}' has {paramCount} parameters (max: 5). Consider using a parameter object or builder pattern." in src/Lintelligent.AnalyzerEngine/Rules/LongParameterListRule.cs
- [ ] T026 [P] [US1] Create LongParameterListRuleTests test class in tests/Lintelligent.AnalyzerEngine.Tests/Rules/LongParameterListRuleTests.cs
- [ ] T027 [P] [US1] Add test: ReturnsNoDiagnostic_WhenMethodHasExactly5Parameters in tests/Lintelligent.AnalyzerEngine.Tests/Rules/LongParameterListRuleTests.cs
- [ ] T028 [P] [US1] Add test: ReturnsDiagnostic_WhenMethodHas6Parameters in tests/Lintelligent.AnalyzerEngine.Tests/Rules/LongParameterListRuleTests.cs
- [ ] T029 [P] [US1] Add test: ReturnsDiagnostic_WhenConstructorHas8Parameters in tests/Lintelligent.AnalyzerEngine.Tests/Rules/LongParameterListRuleTests.cs
- [ ] T030 [P] [US1] Add test: ReturnsNoDiagnostic_WhenMethodHas0Parameters in tests/Lintelligent.AnalyzerEngine.Tests/Rules/LongParameterListRuleTests.cs
- [ ] T031 [P] [US1] Add test: ExcludesThisParameter_ForExtensionMethods in tests/Lintelligent.AnalyzerEngine.Tests/Rules/LongParameterListRuleTests.cs
- [ ] T032 [P] [US1] Add test: VerifiesCorrectMetadata_RuleIdSeverityCategory in tests/Lintelligent.AnalyzerEngine.Tests/Rules/LongParameterListRuleTests.cs
- [ ] T033 [US1] Run tests and verify all pass: dotnet test --filter "FullyQualifiedName~LongParameterListRuleTests"

**Checkpoint**: User Story 1 complete - can detect excessive parameters with correct exclusions

---

## Phase 5: User Story 2 - Complex Conditional Detection (Priority: P1)

**Goal**: Detect if statements nested more than 3 levels deep

**Independent Test**: Analyze method with if statements nested 4 levels - rule returns diagnostic "Conditional nesting depth is 4 (max: 3)" with severity Warning, category "Code Smell"

### Implementation for User Story 2

- [ ] T034 [P] [US2] Create ComplexConditionalRule class implementing IAnalyzerRule in src/Lintelligent.AnalyzerEngine/Rules/ComplexConditionalRule.cs with Id="LNT003", Description="Conditional statements should not be nested more than 3 levels deep", Severity=Warning, Category=CodeSmell
- [ ] T035 [US2] Implement Analyze method using DescendantNodes().OfType<IfStatementSyntax>() in src/Lintelligent.AnalyzerEngine/Rules/ComplexConditionalRule.cs
- [ ] T036 [US2] Add auto-generated code detection in src/Lintelligent.AnalyzerEngine/Rules/ComplexConditionalRule.cs
- [ ] T037 [US2] Implement recursive nesting depth calculation: traverse ancestors counting IfStatementSyntax and SwitchStatementSyntax nodes in src/Lintelligent.AnalyzerEngine/Rules/ComplexConditionalRule.cs
- [ ] T038 [US2] Yield diagnostic when nesting depth > 3 with message: "Conditional nesting depth is {depth} (max: 3). Consider extracting nested logic into separate methods or using guard clauses." in src/Lintelligent.AnalyzerEngine/Rules/ComplexConditionalRule.cs
- [ ] T039 [P] [US2] Create ComplexConditionalRuleTests test class in tests/Lintelligent.AnalyzerEngine.Tests/Rules/ComplexConditionalRuleTests.cs
- [ ] T040 [P] [US2] Add test: ReturnsNoDiagnostic_WhenNestingDepthIs3 in tests/Lintelligent.AnalyzerEngine.Tests/Rules/ComplexConditionalRuleTests.cs
- [ ] T041 [P] [US2] Add test: ReturnsDiagnostic_WhenNestingDepthIs4 in tests/Lintelligent.AnalyzerEngine.Tests/Rules/ComplexConditionalRuleTests.cs
- [ ] T042 [P] [US2] Add test: ReturnsNoDiagnostic_ForIfElseIfChains_SameLevel in tests/Lintelligent.AnalyzerEngine.Tests/Rules/ComplexConditionalRuleTests.cs
- [ ] T043 [P] [US2] Add test: CountsSwitchStatements_InNestingDepth in tests/Lintelligent.AnalyzerEngine.Tests/Rules/ComplexConditionalRuleTests.cs
- [ ] T044 [P] [US2] Add test: VerifiesCorrectMetadata_RuleIdSeverityCategory in tests/Lintelligent.AnalyzerEngine.Tests/Rules/ComplexConditionalRuleTests.cs
- [ ] T045 [US2] Run tests and verify all pass: dotnet test --filter "FullyQualifiedName~ComplexConditionalRuleTests"

**Checkpoint**: User Story 2 complete - can detect deep nesting with correct calculation

---

## Phase 6: User Story 3 - Magic Number Detection (Priority: P2)

**Goal**: Detect hardcoded numeric literals that should be named constants

**Independent Test**: Analyze code with `if (status == 3)` - rule returns diagnostic "Magic number '3' should be replaced with a named constant" with severity Info, category "Code Smell"

### Implementation for User Story 3

- [ ] T046 [P] [US3] Create MagicNumberRule class implementing IAnalyzerRule in src/Lintelligent.AnalyzerEngine/Rules/MagicNumberRule.cs with Id="LNT004", Description="Numeric literals should be replaced with named constants", Severity=Info, Category=CodeSmell
- [ ] T047 [US3] Implement Analyze method using DescendantNodes().OfType<LiteralExpressionSyntax>() filtering IsKind(NumericLiteralExpression) in src/Lintelligent.AnalyzerEngine/Rules/MagicNumberRule.cs
- [ ] T048 [US3] Add auto-generated code detection in src/Lintelligent.AnalyzerEngine/Rules/MagicNumberRule.cs
- [ ] T049 [US3] Implement exclusion logic: skip if literal is 0, 1, or -1 in src/Lintelligent.AnalyzerEngine/Rules/MagicNumberRule.cs
- [ ] T050 [US3] Implement exclusion logic: skip if parent is EqualsValueClauseSyntax with const modifier in src/Lintelligent.AnalyzerEngine/Rules/MagicNumberRule.cs
- [ ] T051 [US3] Yield diagnostic for remaining literals with message: "Magic number '{value}' should be replaced with a named constant for better code clarity." in src/Lintelligent.AnalyzerEngine/Rules/MagicNumberRule.cs
- [ ] T052 [P] [US3] Create MagicNumberRuleTests test class in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MagicNumberRuleTests.cs
- [ ] T053 [P] [US3] Add test: ReturnsNoDiagnostic_ForZeroOneMinus1 in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MagicNumberRuleTests.cs
- [ ] T054 [P] [US3] Add test: ReturnsNoDiagnostic_WhenLiteralIsConstDeclaration in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MagicNumberRuleTests.cs
- [ ] T055 [P] [US3] Add test: ReturnsDiagnostic_ForThreadSleep5000 in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MagicNumberRuleTests.cs
- [ ] T056 [P] [US3] Add test: ReturnsDiagnostic_ForFloatingPointLiteral in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MagicNumberRuleTests.cs
- [ ] T057 [P] [US3] Add test: ReturnsDiagnostic_ForAttributeArguments in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MagicNumberRuleTests.cs
- [ ] T058 [P] [US3] Add test: VerifiesCorrectMetadata_RuleIdSeverityCategory in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MagicNumberRuleTests.cs
- [ ] T059 [US3] Run tests and verify all pass: dotnet test --filter "FullyQualifiedName~MagicNumberRuleTests"

**Checkpoint**: User Story 3 complete - can detect magic numbers with correct exclusions

---

## Phase 7: User Story 4 - God Class Detection (Priority: P2)

**Goal**: Detect classes that are too large (>500 LOC OR >15 methods)

**Independent Test**: Analyze class with 520 lines - rule returns diagnostic "Class has 520 lines (max: 500)" with severity Warning, category "Design"

### Implementation for User Story 4

- [ ] T060 [P] [US4] Create GodClassRule class implementing IAnalyzerRule in src/Lintelligent.AnalyzerEngine/Rules/GodClassRule.cs with Id="LNT005", Description="Classes should not exceed 500 lines of code or 15 methods", Severity=Warning, Category=Design
- [ ] T061 [US4] Implement Analyze method using DescendantNodes().OfType<ClassDeclarationSyntax>() in src/Lintelligent.AnalyzerEngine/Rules/GodClassRule.cs
- [ ] T062 [US4] Add auto-generated code detection in src/Lintelligent.AnalyzerEngine/Rules/GodClassRule.cs
- [ ] T063 [US4] Implement LOC counting: calculate classDecl.Span.End - classDecl.Span.Start and convert to line count in src/Lintelligent.AnalyzerEngine/Rules/GodClassRule.cs
- [ ] T064 [US4] Implement method counting: count MethodDeclarationSyntax, ConstructorDeclarationSyntax, PropertyDeclarationSyntax with explicit accessors in src/Lintelligent.AnalyzerEngine/Rules/GodClassRule.cs
- [ ] T065 [US4] Yield diagnostic when LOC > 500 OR method count > 15 with appropriate message in src/Lintelligent.AnalyzerEngine/Rules/GodClassRule.cs
- [ ] T066 [P] [US4] Create GodClassRuleTests test class in tests/Lintelligent.AnalyzerEngine.Tests/Rules/GodClassRuleTests.cs
- [ ] T067 [P] [US4] Add test: ReturnsNoDiagnostic_WhenClassHasExactly500LinesAnd10Methods in tests/Lintelligent.AnalyzerEngine.Tests/Rules/GodClassRuleTests.cs
- [ ] T068 [P] [US4] Add test: ReturnsDiagnostic_WhenClassHas501Lines in tests/Lintelligent.AnalyzerEngine.Tests/Rules/GodClassRuleTests.cs
- [ ] T069 [P] [US4] Add test: ReturnsDiagnostic_WhenClassHas300LinesAnd16Methods in tests/Lintelligent.AnalyzerEngine.Tests/Rules/GodClassRuleTests.cs
- [ ] T070 [P] [US4] Add test: ReturnsNoDiagnostic_WhenClassHas250LinesAnd14Methods in tests/Lintelligent.AnalyzerEngine.Tests/Rules/GodClassRuleTests.cs
- [ ] T071 [P] [US4] Add test: CountsOnlyActualMethods_NotAutoProperties in tests/Lintelligent.AnalyzerEngine.Tests/Rules/GodClassRuleTests.cs
- [ ] T072 [P] [US4] Add test: VerifiesCorrectMetadata_RuleIdSeverityCategory in tests/Lintelligent.AnalyzerEngine.Tests/Rules/GodClassRuleTests.cs
- [ ] T073 [US4] Run tests and verify all pass: dotnet test --filter "FullyQualifiedName~GodClassRuleTests"

**Checkpoint**: User Story 4 complete - can detect oversized classes with accurate counting

---

## Phase 8: User Story 5 - Dead Code Detection (Priority: P3)

**Goal**: Detect unused private methods and fields

**Independent Test**: Analyze class with uncalled private method - rule returns diagnostic "Private method is never used" with severity Info, category "Maintainability"

### Implementation for User Story 5

- [ ] T074 [P] [US5] Create DeadCodeRule class implementing IAnalyzerRule in src/Lintelligent.AnalyzerEngine/Rules/DeadCodeRule.cs with Id="LNT006", Description="Private members should not be unused", Severity=Info, Category=Maintainability
- [ ] T075 [US5] Implement Analyze method to find private methods and fields using LINQ on DescendantNodes() in src/Lintelligent.AnalyzerEngine/Rules/DeadCodeRule.cs
- [ ] T076 [US5] Add auto-generated code detection in src/Lintelligent.AnalyzerEngine/Rules/DeadCodeRule.cs
- [ ] T077 [US5] Implement syntax-based reference finding: search for IdentifierNameSyntax matching private member name within same class in src/Lintelligent.AnalyzerEngine/Rules/DeadCodeRule.cs
- [ ] T078 [US5] Exclude private methods implementing explicit interface members: check if method name matches pattern 'InterfaceName.MethodName' or if class implements interface with matching member name in src/Lintelligent.AnalyzerEngine/Rules/DeadCodeRule.cs
- [ ] T079 [US5] Yield diagnostic when reference count == 0 with message: "Private {memberType} '{memberName}' is never used. Consider removing it to reduce code clutter." in src/Lintelligent.AnalyzerEngine/Rules/DeadCodeRule.cs
- [ ] T080 [P] [US5] Create DeadCodeRuleTests test class in tests/Lintelligent.AnalyzerEngine.Tests/Rules/DeadCodeRuleTests.cs
- [ ] T081 [P] [US5] Add test: ReturnsNoDiagnostic_WhenPrivateMethodIsCalledOnce in tests/Lintelligent.AnalyzerEngine.Tests/Rules/DeadCodeRuleTests.cs
- [ ] T082 [P] [US5] Add test: ReturnsDiagnostic_WhenPrivateMethodHasZeroCallSites in tests/Lintelligent.AnalyzerEngine.Tests/Rules/DeadCodeRuleTests.cs
- [ ] T083 [P] [US5] Add test: ReturnsDiagnostic_WhenPrivateFieldAssignedButNeverRead in tests/Lintelligent.AnalyzerEngine.Tests/Rules/DeadCodeRuleTests.cs
- [ ] T084 [P] [US5] Add test: ReturnsDiagnostic_WhenPrivateFieldUsedOnlyInDeclaration in tests/Lintelligent.AnalyzerEngine.Tests/Rules/DeadCodeRuleTests.cs
- [ ] T085 [P] [US5] Add test: ReturnsNoDiagnostic_ForPublicMethodWithNoCallSites in tests/Lintelligent.AnalyzerEngine.Tests/Rules/DeadCodeRuleTests.cs
- [ ] T086 [P] [US5] Add test: VerifiesCorrectMetadata_RuleIdSeverityCategory in tests/Lintelligent.AnalyzerEngine.Tests/Rules/DeadCodeRuleTests.cs
- [ ] T087 [US5] Run tests and verify all pass: dotnet test --filter "FullyQualifiedName~DeadCodeRuleTests"

**Checkpoint**: User Story 5 complete - can detect unused private members with syntax-based analysis

---

## Phase 9: User Story 7 - Missing XML Documentation Detection (Priority: P3)

**Goal**: Detect public APIs without XML doc comments

**Independent Test**: Analyze public method without `/// <summary>` - rule returns diagnostic "Public method is missing XML documentation" with severity Info, category "Documentation"

### Implementation for User Story 7

- [ ] T088 [P] [US7] Create MissingXmlDocumentationRule class implementing IAnalyzerRule in src/Lintelligent.AnalyzerEngine/Rules/MissingXmlDocumentationRule.cs with Id="LNT008", Description="Public APIs should have XML documentation comments", Severity=Info, Category=Documentation
- [ ] T089 [US7] Implement Analyze method to find public classes, methods, and properties using DescendantNodes() in src/Lintelligent.AnalyzerEngine/Rules/MissingXmlDocumentationRule.cs
- [ ] T090 [US7] Add auto-generated code detection in src/Lintelligent.AnalyzerEngine/Rules/MissingXmlDocumentationRule.cs
- [ ] T091 [US7] Filter for public accessibility: check modifiers contain 'public' keyword in src/Lintelligent.AnalyzerEngine/Rules/MissingXmlDocumentationRule.cs
- [ ] T092 [US7] Check for XML doc comments using GetLeadingTrivia().Any(t => t.IsKind(SyntaxKind.SingleLineDocumentationCommentTrivia)) in src/Lintelligent.AnalyzerEngine/Rules/MissingXmlDocumentationRule.cs
- [ ] T093 [US7] Accept <inheritdoc/> as valid documentation in src/Lintelligent.AnalyzerEngine/Rules/MissingXmlDocumentationRule.cs
- [ ] T094 [US7] Yield diagnostic when public member lacks doc with message: "Public {memberType} '{memberName}' is missing XML documentation. Add a summary describing its purpose and usage." in src/Lintelligent.AnalyzerEngine/Rules/MissingXmlDocumentationRule.cs
- [ ] T095 [P] [US7] Create MissingXmlDocumentationRuleTests test class in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MissingXmlDocumentationRuleTests.cs
- [ ] T096 [P] [US7] Add test: ReturnsNoDiagnostic_WhenPublicMethodHasSummaryComment in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MissingXmlDocumentationRuleTests.cs
- [ ] T097 [P] [US7] Add test: ReturnsDiagnostic_WhenPublicMethodHasNoDocComment in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MissingXmlDocumentationRuleTests.cs
- [ ] T098 [P] [US7] Add test: ReturnsNoDiagnostic_ForPrivateMethodWithoutDoc in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MissingXmlDocumentationRuleTests.cs
- [ ] T099 [P] [US7] Add test: ReturnsDiagnostic_WhenPublicPropertyHasNoDoc in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MissingXmlDocumentationRuleTests.cs
- [ ] T100 [P] [US7] Add test: ReturnsDiagnostic_WhenPublicClassHasNoDoc in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MissingXmlDocumentationRuleTests.cs
- [ ] T101 [P] [US7] Add test: ReturnsDiagnostic_WhenOnlyRegularComment_NotXmlDoc in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MissingXmlDocumentationRuleTests.cs
- [ ] T102 [P] [US7] Add test: ReturnsNoDiagnostic_WhenInheritdocPresent in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MissingXmlDocumentationRuleTests.cs
- [ ] T103 [P] [US7] Add test: VerifiesCorrectMetadata_RuleIdSeverityCategory in tests/Lintelligent.AnalyzerEngine.Tests/Rules/MissingXmlDocumentationRuleTests.cs
- [ ] T104 [US7] Run tests and verify all pass: dotnet test --filter "FullyQualifiedName~MissingXmlDocumentationRuleTests"

**Checkpoint**: User Story 7 complete - can detect missing documentation with trivia inspection

---

## Phase 10: Polish & Cross-Cutting Concerns

**Purpose**: Validate integration, performance, and complete feature delivery

- [ ] T105 Verify all 8 rules present and implementing IAnalyzerRule: dotnet build succeeds
- [ ] T106 Run full test suite to verify no regressions: dotnet test
- [ ] T107 Create integration test analyzing complex file with all rule violations in tests/Lintelligent.AnalyzerEngine.Tests/RulesIntegrationTests.cs
- [ ] T108 Verify integration test detects all 8 rule violations correctly
- [ ] T109 Create performance benchmark analyzing 1000-line file with all rules in tests/Lintelligent.AnalyzerEngine.Tests/RulesPerformanceTests.cs
- [ ] T110 Verify performance: all 8 rules complete analysis in <500ms per rule
- [ ] T111 Calculate test coverage: dotnet test --collect:"XPlat Code Coverage"
- [ ] T112 Verify test coverage meets ‚â•95% line coverage requirement
- [ ] T113 Document each rule (what/why/how) in specs/005-core-rule-library/rules-documentation.md with sections for all 8 rules
- [ ] T114 Final verification: dotnet build && dotnet test succeeds with zero failures

**Checkpoint**: Feature complete - all rules implemented, tested, documented, and performance validated

---

## Implementation Strategy

**MVP Scope**: User Story 6 (Exception Swallowing) - Simplest P1 rule validates complete pattern

**Incremental Delivery**:
1. **Setup & Foundation** (Phase 1-2): Infrastructure ready (~15 min)
2. **First P1 Rule** (Phase 3): Validates implementation pattern (~30 min)
3. **Remaining P1 Rules** (Phase 4-5): High-priority detection (~2 hours)
4. **P2 Rules** (Phase 6-7): Additional value (~3 hours)
5. **P3 Rules** (Phase 8-9): Complete coverage (~3 hours)
6. **Polish** (Phase 10): Quality gates (~1 hour)

**Total Estimated Time**: 8-12 hours

---

## Dependencies

### User Story Completion Order

```
Phase 1 (Setup)
  ‚Üì
Phase 2 (Foundation - LongMethodRule Enhancement)
  ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Phase 3 (US6 - P1)  ‚îÇ Phase 4 (US1 - P1)  ‚îÇ Phase 5 (US2 - P1)  ‚îÇ
‚îÇ Exception Swallow   ‚îÇ Long Param List     ‚îÇ Complex Conditional ‚îÇ
‚îÇ INDEPENDENT         ‚îÇ INDEPENDENT         ‚îÇ INDEPENDENT         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Phase 6 (US3 - P2)              ‚îÇ Phase 7 (US4 - P2)              ‚îÇ
‚îÇ Magic Number                    ‚îÇ God Class                       ‚îÇ
‚îÇ INDEPENDENT                     ‚îÇ INDEPENDENT                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Phase 8 (US5 - P3)              ‚îÇ Phase 9 (US7 - P3)              ‚îÇ
‚îÇ Dead Code                       ‚îÇ Missing XML Doc                 ‚îÇ
‚îÇ INDEPENDENT                     ‚îÇ INDEPENDENT                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  ‚Üì
Phase 10 (Polish)
```

**Critical Path**: Phase 1 ‚Üí Phase 2 ‚Üí Any User Story ‚Üí Phase 10

**Parallel Opportunities**:
- After Phase 2: All user story phases (3-9) can run in parallel
- Within each phase: Most test creation tasks marked [P] can run in parallel with implementation
- Tasks T001-T002 (add constants) can run in parallel

---

## Parallel Execution Examples

### Example 1: After Foundation Complete

**Developer A**: Implements User Story 6 (Exception Swallowing)  
**Developer B**: Implements User Story 1 (Long Parameter List)  
**Developer C**: Implements User Story 2 (Complex Conditional)

All three can work simultaneously with zero conflicts (different files, independent logic).

### Example 2: Within User Story 6

**Developer implements**: T008 (create rule class)  
**Developer runs in parallel**: T013 (create test class) - different file  
**Developer implements**: T009-T012 (rule logic) sequentially  
**Developer runs in parallel**: T014-T019 (all tests) - can write tests for expected behavior while implementation in progress

### Example 3: Test Writing

After any rule class is created (T008, T021, T034, etc.), all test tasks for that story can be written in parallel since they're in the same test class and test independent scenarios.

---

## Validation Commands

**Build Verification**: `dotnet build`  
**All Tests**: `dotnet test`  
**Specific Rule Tests**: `dotnet test --filter "FullyQualifiedName~[RuleName]Tests"`  
**Coverage**: `dotnet test --collect:"XPlat Code Coverage"`  
**Performance Check**: Run performance test and verify <500ms per rule for 1000-line file

---

## Task Summary

**Total Tasks**: 114  
**By Phase**:
- Phase 1 (Setup): 3 tasks
- Phase 2 (Foundation): 4 tasks
- Phase 3 (US6 - P1): 13 tasks
- Phase 4 (US1 - P1): 13 tasks
- Phase 5 (US2 - P1): 12 tasks
- Phase 6 (US3 - P2): 14 tasks
- Phase 7 (US4 - P2): 14 tasks
- Phase 8 (US5 - P3): 14 tasks
- Phase 9 (US7 - P3): 17 tasks
- Phase 10 (Polish): 10 tasks

**Parallelizable Tasks**: 71 tasks marked with [P]

**Independent Test Criteria**:
- **US6**: Empty catch block ‚Üí diagnostic returned
- **US1**: 6 parameters ‚Üí diagnostic with correct count
- **US2**: Nesting depth 4 ‚Üí diagnostic with depth value
- **US3**: Magic number 3 ‚Üí diagnostic suggesting constant
- **US4**: 520 LOC ‚Üí diagnostic with line count
- **US5**: Unused private method ‚Üí diagnostic identifying member
- **US7**: Public method without doc ‚Üí diagnostic identifying member

**Suggested MVP Scope**: Phase 1 + Phase 2 + Phase 3 (US6) = 20 tasks = ~1 hour
