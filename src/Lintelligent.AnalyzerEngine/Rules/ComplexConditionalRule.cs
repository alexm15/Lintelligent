using Lintelligent.AnalyzerEngine.Abstractions;
using Lintelligent.AnalyzerEngine.Results;

namespace Lintelligent.AnalyzerEngine.Rules;

public class ComplexConditionalRule : IAnalyzerRule
{
    private const int MaxNestingDepth = 3;
    public string Id => "LNT003";
    public string Description => "Conditional statements should not be nested more than 3 levels deep";
    public Severity Severity => Severity.Warning;
    public string Category => DiagnosticCategories.CodeSmell;

    public IEnumerable<DiagnosticResult> Analyze(SyntaxTree tree)
    {
        if (IsGeneratedCode(tree))
            yield break;

        SyntaxNode root = tree.GetRoot();

        // Check both if statements and switch statements
        IEnumerable<IfStatementSyntax> ifStatements = root.DescendantNodes().OfType<IfStatementSyntax>();
        IEnumerable<SwitchStatementSyntax> switchStatements = root.DescendantNodes().OfType<SwitchStatementSyntax>();

        IEnumerable<SyntaxNode> allConditionals = ifStatements
            .Concat(switchStatements.Cast<SyntaxNode>());

        foreach (SyntaxNode conditional in allConditionals)
        {
            var depth = CalculateNestingDepth(conditional);

            if (depth <= MaxNestingDepth) continue;
            var line = conditional.GetLocation().GetLineSpan().StartLinePosition.Line + 1;
            var message = $"Conditional nesting depth is {depth} (max: {MaxNestingDepth}). " +
                          "Consider extracting nested logic into separate methods or using guard clauses.";

            yield return new DiagnosticResult(
                tree.FilePath,
                Id,
                message,
                line,
                Severity,
                Category
            );
        }
    }

    private static int CalculateNestingDepth(SyntaxNode node)
    {
        // Start at 1 to count the current node itself
        var depth = 1;
        SyntaxNode? current = node.Parent;

        while (current != null)
        {
            if (current is IfStatementSyntax or SwitchStatementSyntax)
            {
                // Check if this is an else-if chain (not true nesting)
                // An else-if is when an IfStatement is the only statement in an ElseClause
                if (current is IfStatementSyntax {Parent: ElseClauseSyntax elseClause} ifStmt &&
                    elseClause.Statement == ifStmt)
                {
                    // This is an else-if, skip counting it as nesting
                    // But continue checking its parents
                }
                else
                    depth++;
            }

            current = current.Parent;
        }

        return depth;
    }

    private static bool IsGeneratedCode(SyntaxTree tree)
    {
        var fileName = Path.GetFileName(tree.FilePath);
        if (fileName.EndsWith(".Designer.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.EndsWith(".g.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.Contains(".Generated."))
            return true;

        SyntaxNode root = tree.GetRoot();
        IEnumerable<SyntaxTrivia> leadingTrivia = root.GetLeadingTrivia().Take(10);
        return leadingTrivia.Any(t =>
            t.ToString().Contains("<auto-generated>") ||
            t.ToString().Contains("<auto-generated />"));
    }
}
