using Lintelligent.AnalyzerEngine.Abstractions;
using Lintelligent.AnalyzerEngine.Results;

namespace Lintelligent.AnalyzerEngine.Rules;

public class ExceptionSwallowingRule : IAnalyzerRule
{
    public string Id => "LNT007";
    public string Description => "Catch blocks should not be empty";
    public Severity Severity => Severity.Warning;
    public string Category => DiagnosticCategories.CodeSmell;

    public IEnumerable<DiagnosticResult> Analyze(SyntaxTree tree)
    {
        if (IsGeneratedCode(tree))
            yield break;

        SyntaxNode root = tree.GetRoot();
        IEnumerable<CatchClauseSyntax> emptyCatches = root.DescendantNodes()
            .OfType<CatchClauseSyntax>()
            .Where(c => c.Block.Statements.Count == 0);

        foreach (CatchClauseSyntax catchClause in emptyCatches)
        {
            var line = catchClause.GetLocation().GetLineSpan().StartLinePosition.Line + 1;

            yield return new DiagnosticResult(
                tree.FilePath,
                Id,
                "Empty catch block suppresses exceptions. " +
                "Consider logging the exception or removing the try-catch if error handling is not needed.",
                line,
                Severity,
                Category
            );
        }
    }

    private static bool IsGeneratedCode(SyntaxTree tree)
    {
        var fileName = Path.GetFileName(tree.FilePath);
        if (fileName.EndsWith(".Designer.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.EndsWith(".g.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.Contains(".Generated."))
            return true;

        SyntaxNode root = tree.GetRoot();
        IEnumerable<SyntaxTrivia> leadingTrivia = root.GetLeadingTrivia().Take(10);
        return leadingTrivia.Any(t =>
            t.ToString().Contains("<auto-generated>") ||
            t.ToString().Contains("<auto-generated />"));
    }
}
