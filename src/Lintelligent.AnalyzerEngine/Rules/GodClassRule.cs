using Lintelligent.AnalyzerEngine.Abstractions;
using Lintelligent.AnalyzerEngine.Results;
using Microsoft.CodeAnalysis.Text;

namespace Lintelligent.AnalyzerEngine.Rules;

public class GodClassRule : IAnalyzerRule
{
    private const int MaxLines = 500;
    private const int MaxMethods = 15;
    public string Id => "LNT005";
    public string Description => "Classes should not exceed 500 lines of code or 15 methods";
    public Severity Severity => Severity.Warning;
    public string Category => DiagnosticCategories.Design;

    public IEnumerable<DiagnosticResult> Analyze(SyntaxTree tree)
    {
        if (IsGeneratedCode(tree))
            yield break;

        SyntaxNode root = tree.GetRoot();
        IEnumerable<ClassDeclarationSyntax> classes = root.DescendantNodes().OfType<ClassDeclarationSyntax>();

        foreach (ClassDeclarationSyntax classDecl in classes)
        {
            var lineCount = CalculateLineCount(classDecl, tree);
            var methodCount = CountMethods(classDecl);

            if (lineCount <= MaxLines && methodCount <= MaxMethods) continue;
            var line = classDecl.GetLocation().GetLineSpan().StartLinePosition.Line + 1;
            var className = classDecl.Identifier.ValueText;

            var message = lineCount switch
            {
                > MaxLines when methodCount > MaxMethods =>
                    $"Class '{className}' has {lineCount} lines (max: {MaxLines}) and {methodCount} methods (max: {MaxMethods}). Consider splitting into smaller, focused classes by responsibility.",
                > MaxLines => $"Class '{className}' has {lineCount} lines (max: {MaxLines}). " +
                              "Consider splitting into smaller, focused classes by responsibility.",
                _ => $"Class '{className}' has {methodCount} methods (max: {MaxMethods}). " +
                     "Consider splitting into smaller, focused classes by responsibility."
            };

            yield return new DiagnosticResult(
                tree.FilePath,
                Id,
                message,
                line,
                Severity,
                Category
            );
        }
    }

    private static int CalculateLineCount(ClassDeclarationSyntax classDecl, SyntaxTree tree)
    {
        TextSpan span = classDecl.FullSpan;
        FileLinePositionSpan lineSpan = tree.GetLineSpan(span);

        // Add 1 because line numbers are 0-indexed, and we want inclusive count
        return lineSpan.EndLinePosition.Line - lineSpan.StartLinePosition.Line + 1;
    }

    private static int CountMethods(ClassDeclarationSyntax classDecl)
    {
        // Count only explicit method declarations (not constructors, properties, or auto-property accessors)
        return classDecl.DescendantNodes()
            .OfType<MethodDeclarationSyntax>()
            .Count();
    }

    private static bool IsGeneratedCode(SyntaxTree tree)
    {
        var fileName = Path.GetFileName(tree.FilePath);
        if (fileName.EndsWith(".Designer.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.EndsWith(".g.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.Contains(".Generated."))
            return true;

        SyntaxNode root = tree.GetRoot();
        IEnumerable<SyntaxTrivia> leadingTrivia = root.GetLeadingTrivia().Take(10);
        return leadingTrivia.Any(t =>
            t.ToString().Contains("<auto-generated>") ||
            t.ToString().Contains("<auto-generated />"));
    }
}
