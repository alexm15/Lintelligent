using Lintelligent.AnalyzerEngine.Abstractions;
using Lintelligent.AnalyzerEngine.Results;

namespace Lintelligent.AnalyzerEngine.Rules;

public class LongParameterListRule : IAnalyzerRule
{
    public string Id => "LNT002";
    public string Description => "Methods should not have more than 5 parameters";
    public Severity Severity => Severity.Warning;
    public string Category => DiagnosticCategories.CodeSmell;

    private const int MaxParameters = 5;

    public IEnumerable<DiagnosticResult> Analyze(SyntaxTree tree)
    {
        if (IsGeneratedCode(tree))
            yield break;

        var root = tree.GetRoot();
        var methods = root.DescendantNodes()
            .OfType<BaseMethodDeclarationSyntax>();

        foreach (var method in methods)
        {
            var parameters = method.ParameterList?.Parameters ?? default;
            var paramCount = parameters.Count;

            // For extension methods, exclude the 'this' parameter
            if (IsExtensionMethod(method))
                paramCount--;

            if (paramCount > MaxParameters)
            {
                var line = method.GetLocation().GetLineSpan().StartLinePosition.Line + 1;
                var methodName = GetMethodName(method);
                var message = $"Method '{methodName}' has {paramCount} parameters (max: {MaxParameters}). " +
                             "Consider using a parameter object or builder pattern.";

                yield return new DiagnosticResult(
                    tree.FilePath,
                    Id,
                    message,
                    line,
                    Severity,
                    Category
                );
            }
        }
    }

    private static bool IsExtensionMethod(BaseMethodDeclarationSyntax method)
    {
        // Extension methods must be static and have at least one parameter with 'this' modifier
        if (method is not MethodDeclarationSyntax methodDecl)
            return false;

        if (!methodDecl.Modifiers.Any(SyntaxKind.StaticKeyword))
            return false;

        var firstParam = methodDecl.ParameterList?.Parameters.FirstOrDefault();
        return firstParam?.Modifiers.Any(SyntaxKind.ThisKeyword) == true;
    }

    private static string GetMethodName(BaseMethodDeclarationSyntax method)
    {
        return method switch
        {
            MethodDeclarationSyntax m => m.Identifier.Text,
            ConstructorDeclarationSyntax c => c.Identifier.Text,
            DestructorDeclarationSyntax d => "~" + d.Identifier.Text,
            OperatorDeclarationSyntax o => "operator " + o.OperatorToken.Text,
            ConversionOperatorDeclarationSyntax co => "operator " + co.Type.ToString(),
            _ => "Unknown"
        };
    }

    private static bool IsGeneratedCode(SyntaxTree tree)
    {
        string fileName = Path.GetFileName(tree.FilePath);
        if (fileName.EndsWith(".Designer.cs") || 
            fileName.EndsWith(".g.cs") || 
            fileName.Contains(".Generated."))
            return true;

        var root = tree.GetRoot();
        var leadingTrivia = root.GetLeadingTrivia().Take(10);
        return leadingTrivia.Any(t => 
            t.ToString().Contains("<auto-generated>") ||
            t.ToString().Contains("<auto-generated />"));
    }
}
