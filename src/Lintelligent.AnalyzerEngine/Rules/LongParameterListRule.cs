using Lintelligent.AnalyzerEngine.Abstractions;
using Lintelligent.AnalyzerEngine.Results;

namespace Lintelligent.AnalyzerEngine.Rules;

public class LongParameterListRule : IAnalyzerRule
{
    private const int MaxParameters = 5;
    public string Id => "LNT002";
    public string Description => "Methods should not have more than 5 parameters";
    public Severity Severity => Severity.Warning;
    public string Category => DiagnosticCategories.CodeSmell;

    public IEnumerable<DiagnosticResult> Analyze(SyntaxTree tree)
    {
        if (IsGeneratedCode(tree))
            yield break;

        SyntaxNode root = tree.GetRoot();
        IEnumerable<BaseMethodDeclarationSyntax> methods = root.DescendantNodes()
            .OfType<BaseMethodDeclarationSyntax>();

        foreach (BaseMethodDeclarationSyntax method in methods)
        {
            SeparatedSyntaxList<ParameterSyntax> parameters = method.ParameterList?.Parameters ?? default;
            var paramCount = parameters.Count;

            // For extension methods, exclude the 'this' parameter
            if (IsExtensionMethod(method))
                paramCount--;

            if (paramCount <= MaxParameters) continue;
            var line = method.GetLocation().GetLineSpan().StartLinePosition.Line + 1;
            var methodName = GetMethodName(method);
            var message = $"Method '{methodName}' has {paramCount} parameters (max: {MaxParameters}). " +
                          "Consider using a parameter object or builder pattern.";

            yield return new DiagnosticResult(
                tree.FilePath,
                Id,
                message,
                line,
                Severity,
                Category
            );
        }
    }

    private static bool IsExtensionMethod(BaseMethodDeclarationSyntax method)
    {
        // Extension methods must be static and have at least one parameter with 'this' modifier
        if (method is not MethodDeclarationSyntax methodDecl)
            return false;

        if (!methodDecl.Modifiers.Any(SyntaxKind.StaticKeyword))
            return false;

        ParameterSyntax? firstParam = methodDecl.ParameterList?.Parameters.FirstOrDefault();
        return firstParam?.Modifiers.Any(SyntaxKind.ThisKeyword) == true;
    }

    private static string GetMethodName(BaseMethodDeclarationSyntax method)
    {
        return method switch
        {
            MethodDeclarationSyntax m => m.Identifier.Text,
            ConstructorDeclarationSyntax c => c.Identifier.Text,
            DestructorDeclarationSyntax d => "~" + d.Identifier.Text,
            OperatorDeclarationSyntax o => "operator " + o.OperatorToken.Text,
            ConversionOperatorDeclarationSyntax co => "operator " + co.Type,
            _ => "Unknown"
        };
    }

    private static bool IsGeneratedCode(SyntaxTree tree)
    {
        var fileName = Path.GetFileName(tree.FilePath);
        if (fileName.EndsWith(".Designer.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.EndsWith(".g.cs", StringComparison.OrdinalIgnoreCase) ||
            fileName.Contains(".Generated."))
            return true;

        SyntaxNode root = tree.GetRoot();
        IEnumerable<SyntaxTrivia> leadingTrivia = root.GetLeadingTrivia().Take(10);
        return leadingTrivia.Any(t =>
            t.ToString().Contains("<auto-generated>") ||
            t.ToString().Contains("<auto-generated />"));
    }
}
