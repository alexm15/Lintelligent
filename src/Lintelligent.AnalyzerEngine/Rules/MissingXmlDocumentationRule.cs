using Lintelligent.AnalyzerEngine.Abstractions;
using Lintelligent.AnalyzerEngine.Results;

namespace Lintelligent.AnalyzerEngine.Rules;

public class MissingXmlDocumentationRule : IAnalyzerRule
{
    public string Id => "LNT008";
    public string Description => "Public APIs should have XML documentation";
    public Severity Severity => Severity.Info;
    public string Category => DiagnosticCategories.Documentation;

    public IEnumerable<DiagnosticResult> Analyze(SyntaxTree tree)
    {
        if (IsGeneratedCode(tree))
            yield break;

        var root = tree.GetRoot();

        // Check classes
        foreach (var classDecl in root.DescendantNodes().OfType<ClassDeclarationSyntax>())
        {
            if (IsPublicOrProtected(classDecl.Modifiers) && !HasXmlDocumentation(classDecl))
            {
                var className = classDecl.Identifier.ValueText;
                var line = classDecl.GetLocation().GetLineSpan().StartLinePosition.Line + 1;
                var message = $"Public class '{className}' is missing XML documentation. " +
                             "Add a /// <summary> comment to describe the API.";

                yield return new DiagnosticResult(
                    tree.FilePath,
                    Id,
                    message,
                    line,
                    Severity,
                    Category
                );
            }
        }

        // Check methods
        foreach (var methodDecl in root.DescendantNodes().OfType<MethodDeclarationSyntax>())
        {
            if (IsPublicOrProtected(methodDecl.Modifiers) && !HasXmlDocumentation(methodDecl))
            {
                var methodName = methodDecl.Identifier.ValueText;
                var line = methodDecl.GetLocation().GetLineSpan().StartLinePosition.Line + 1;
                var message = $"Public method '{methodName}' is missing XML documentation. " +
                             "Add a /// <summary> comment to describe the API.";

                yield return new DiagnosticResult(
                    tree.FilePath,
                    Id,
                    message,
                    line,
                    Severity,
                    Category
                );
            }
        }

        // Check properties
        foreach (var propertyDecl in root.DescendantNodes().OfType<PropertyDeclarationSyntax>())
        {
            if (IsPublicOrProtected(propertyDecl.Modifiers) && !HasXmlDocumentation(propertyDecl))
            {
                var propertyName = propertyDecl.Identifier.ValueText;
                var line = propertyDecl.GetLocation().GetLineSpan().StartLinePosition.Line + 1;
                var message = $"Public property '{propertyName}' is missing XML documentation. " +
                             "Add a /// <summary> comment to describe the API.";

                yield return new DiagnosticResult(
                    tree.FilePath,
                    Id,
                    message,
                    line,
                    Severity,
                    Category
                );
            }
        }
    }

    private static bool IsPublicOrProtected(SyntaxTokenList modifiers)
    {
        return modifiers.Any(SyntaxKind.PublicKeyword) || 
               modifiers.Any(SyntaxKind.ProtectedKeyword);
    }

    private static bool HasXmlDocumentation(SyntaxNode node)
    {
        var leadingTrivia = node.GetLeadingTrivia();

        // Check for XML documentation comment trivia
        foreach (var trivia in leadingTrivia)
        {
            if (trivia.IsKind(SyntaxKind.SingleLineDocumentationCommentTrivia) ||
                trivia.IsKind(SyntaxKind.MultiLineDocumentationCommentTrivia))
            {
                var triviaText = trivia.ToString();

                // Check for <summary> or <inheritdoc />
                if (triviaText.Contains("<summary") || 
                    triviaText.Contains("<inheritdoc"))
                {
                    return true;
                }
            }
        }

        return false;
    }

    private static bool IsGeneratedCode(SyntaxTree tree)
    {
        string fileName = Path.GetFileName(tree.FilePath);
        if (fileName.EndsWith(".Designer.cs") || 
            fileName.EndsWith(".g.cs") || 
            fileName.Contains(".Generated."))
            return true;

        var root = tree.GetRoot();
        var leadingTrivia = root.GetLeadingTrivia().Take(10);
        return leadingTrivia.Any(t => 
            t.ToString().Contains("<auto-generated>") ||
            t.ToString().Contains("<auto-generated />"));
    }
}
